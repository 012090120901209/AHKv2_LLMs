{
  "version": "1.0.0",
  "lastUpdated": "2025-12-20T00:00:00Z",
  "totalScripts": 25,
  "categories": [
    "GUI",
    "Hotkeys",
    "File Operations",
    "System",
    "Text Processing",
    "Automation",
    "Classes",
    "Networking",
    "Windows API",
    "Utilities"
  ],
  "scripts": [
    {
      "id": "gui-basic-window",
      "title": "Basic GUI Window",
      "category": "GUI",
      "description": "Creates a basic GUI window with controls",
      "tags": ["gui", "window", "controls", "beginner"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-01",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass BasicWindow {\n    __New() {\n        this.gui := Gui('+Resize', 'My Application')\n        this.gui.SetFont('s10', 'Segoe UI')\n        \n        this.gui.AddText('w300', 'Enter your name:')\n        this.nameEdit := this.gui.AddEdit('w300 vUserName')\n        \n        this.submitBtn := this.gui.AddButton('w100', 'Submit')\n        this.submitBtn.OnEvent('Click', this.OnSubmit.Bind(this))\n        \n        this.gui.OnEvent('Close', (*) => ExitApp())\n        this.gui.Show()\n    }\n    \n    OnSubmit(*) {\n        saved := this.gui.Submit(false)\n        MsgBox('Hello, ' saved.UserName '!')\n    }\n}\n\napp := BasicWindow()\n```"
    },
    {
      "id": "gui-dark-mode",
      "title": "Dark Mode GUI",
      "category": "GUI",
      "description": "GUI with Windows 11 dark mode support using DllCall",
      "tags": ["gui", "dark-mode", "windows-api", "theming"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-05",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass DarkModeGUI {\n    static DWMWA_USE_IMMERSIVE_DARK_MODE := 20\n    \n    __New() {\n        this.gui := Gui('+Resize', 'Dark Mode App')\n        this.gui.BackColor := '0x1a1a1a'\n        \n        this.ApplyDarkMode(this.gui.Hwnd)\n        \n        this.gui.SetFont('s10 cWhite', 'Segoe UI')\n        this.gui.AddText('w300', 'Dark mode enabled!')\n        \n        this.gui.AddButton('w100 BackgroundBlack', 'Click Me')\n        this.gui.Show()\n    }\n    \n    ApplyDarkMode(hwnd) {\n        darkMode := 1\n        DllCall('dwmapi\\DwmSetWindowAttribute',\n            'Ptr', hwnd,\n            'Int', DarkModeGUI.DWMWA_USE_IMMERSIVE_DARK_MODE,\n            'Int*', &darkMode,\n            'Int', 4)\n    }\n}\n\napp := DarkModeGUI()\n```"
    },
    {
      "id": "gui-listview",
      "title": "ListView with Data Binding",
      "category": "GUI",
      "description": "Advanced ListView with sorting and data management",
      "tags": ["gui", "listview", "data", "sorting"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-08",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass DataListView {\n    __New() {\n        this.data := Map()\n        this.gui := Gui('+Resize', 'Data Manager')\n        this.gui.SetFont('s10', 'Segoe UI')\n        \n        this.lv := this.gui.AddListView('w400 h300 Grid', ['ID', 'Name', 'Value'])\n        this.lv.OnEvent('DoubleClick', this.OnItemDoubleClick.Bind(this))\n        \n        this.LoadSampleData()\n        this.gui.Show()\n    }\n    \n    LoadSampleData() {\n        items := [\n            {id: 1, name: 'Alpha', value: 100},\n            {id: 2, name: 'Beta', value: 200},\n            {id: 3, name: 'Gamma', value: 150}\n        ]\n        \n        for item in items {\n            this.lv.Add(, item.id, item.name, item.value)\n            this.data[item.id] := item\n        }\n        \n        this.lv.ModifyCol(1, 'AutoHdr')\n        this.lv.ModifyCol(2, 'AutoHdr')\n        this.lv.ModifyCol(3, 'AutoHdr Integer')\n    }\n    \n    OnItemDoubleClick(lv, rowNum) {\n        if rowNum {\n            id := lv.GetText(rowNum, 1)\n            MsgBox('Selected: ' this.data[Integer(id)].name)\n        }\n    }\n}\n\napp := DataListView()\n```"
    },
    {
      "id": "hotkey-manager",
      "title": "Hotkey Manager Class",
      "category": "Hotkeys",
      "description": "Dynamic hotkey registration and management",
      "tags": ["hotkeys", "class", "dynamic", "management"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-02",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass HotkeyManager {\n    static hotkeys := Map()\n    \n    static Register(keyCombo, callback, context := '') {\n        id := keyCombo (context ? '_' context : '')\n        \n        if this.hotkeys.Has(id)\n            this.Unregister(keyCombo, context)\n        \n        Hotkey(keyCombo, callback, 'On')\n        this.hotkeys[id] := {key: keyCombo, callback: callback, context: context}\n        \n        return id\n    }\n    \n    static Unregister(keyCombo, context := '') {\n        id := keyCombo (context ? '_' context : '')\n        \n        if this.hotkeys.Has(id) {\n            Hotkey(keyCombo, 'Off')\n            this.hotkeys.Delete(id)\n            return true\n        }\n        return false\n    }\n    \n    static ListAll() {\n        result := []\n        for id, hk in this.hotkeys\n            result.Push({id: id, key: hk.key, context: hk.context})\n        return result\n    }\n}\n\n; Usage\nHotkeyManager.Register('^!t', (*) => MsgBox('Test hotkey!'))\nHotkeyManager.Register('^!r', (*) => Reload())\n```"
    },
    {
      "id": "tap-hold-system",
      "title": "Tap and Hold Detection",
      "category": "Hotkeys",
      "description": "Distinguish between tap and hold key actions",
      "tags": ["hotkeys", "tap", "hold", "input"],
      "difficulty": "advanced",
      "dateAdded": "2025-12-10",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass TapHoldKey {\n    __New(key, tapAction, holdAction, holdThreshold := 300) {\n        this.key := key\n        this.tapAction := tapAction\n        this.holdAction := holdAction\n        this.holdThreshold := holdThreshold\n        this.pressTime := 0\n        \n        Hotkey('*' key, this.OnKeyDown.Bind(this))\n        Hotkey('*' key ' Up', this.OnKeyUp.Bind(this))\n    }\n    \n    OnKeyDown(*) {\n        if !this.pressTime\n            this.pressTime := A_TickCount\n    }\n    \n    OnKeyUp(*) {\n        if this.pressTime {\n            elapsed := A_TickCount - this.pressTime\n            this.pressTime := 0\n            \n            if elapsed >= this.holdThreshold\n                this.holdAction.Call()\n            else\n                this.tapAction.Call()\n        }\n    }\n}\n\n; Space: tap = space, hold = ctrl\ncapsHandler := TapHoldKey('CapsLock',\n    () => Send('{Esc}'),\n    () => Send('^'))\n```"
    },
    {
      "id": "file-watcher",
      "title": "File System Watcher",
      "category": "File Operations",
      "description": "Monitor directory for file changes",
      "tags": ["files", "watcher", "monitoring", "events"],
      "difficulty": "advanced",
      "dateAdded": "2025-12-03",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass FileWatcher {\n    __New(directory, callback, filter := '*.*') {\n        this.directory := directory\n        this.callback := callback\n        this.filter := filter\n        this.fileStates := Map()\n        this.running := false\n    }\n    \n    Start(interval := 1000) {\n        this.running := true\n        this.ScanDirectory()\n        SetTimer(this.CheckChanges.Bind(this), interval)\n    }\n    \n    Stop() {\n        this.running := false\n        SetTimer(this.CheckChanges.Bind(this), 0)\n    }\n    \n    ScanDirectory() {\n        loop files this.directory '\\' this.filter, 'F' {\n            this.fileStates[A_LoopFilePath] := FileGetTime(A_LoopFilePath)\n        }\n    }\n    \n    CheckChanges() {\n        currentFiles := Map()\n        \n        loop files this.directory '\\' this.filter, 'F' {\n            path := A_LoopFilePath\n            modTime := FileGetTime(path)\n            currentFiles[path] := modTime\n            \n            if !this.fileStates.Has(path)\n                this.callback.Call('created', path)\n            else if this.fileStates[path] != modTime\n                this.callback.Call('modified', path)\n        }\n        \n        for path, time in this.fileStates {\n            if !currentFiles.Has(path)\n                this.callback.Call('deleted', path)\n        }\n        \n        this.fileStates := currentFiles\n    }\n}\n\n; Usage\nwatcher := FileWatcher(A_Desktop, (event, path) => ToolTip(event ': ' path))\nwatcher.Start()\n```"
    },
    {
      "id": "json-handler",
      "title": "JSON File Handler",
      "category": "File Operations",
      "description": "Read and write JSON files with validation",
      "tags": ["json", "files", "parsing", "serialization"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-04",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n#Include <JSON>  ; Requires JSON library\n\nclass JsonFile {\n    __New(filePath) {\n        this.filePath := filePath\n        this.data := Map()\n    }\n    \n    Load() {\n        if FileExist(this.filePath) {\n            content := FileRead(this.filePath, 'UTF-8')\n            this.data := JSON.Load(content)\n            return true\n        }\n        return false\n    }\n    \n    Save(pretty := true) {\n        content := JSON.Dump(this.data, pretty ? 4 : 0)\n        \n        if FileExist(this.filePath)\n            FileDelete(this.filePath)\n        \n        FileAppend(content, this.filePath, 'UTF-8')\n        return true\n    }\n    \n    Get(key, defaultVal := '') {\n        return this.data.Has(key) ? this.data[key] : defaultVal\n    }\n    \n    Set(key, value) {\n        this.data[key] := value\n        return this\n    }\n}\n\n; Usage\nconfig := JsonFile(A_ScriptDir '\\config.json')\nconfig.Load()\nconfig.Set('theme', 'dark').Set('fontSize', 14)\nconfig.Save()\n```"
    },
    {
      "id": "ini-config",
      "title": "INI Configuration Manager",
      "category": "File Operations",
      "description": "Manage application settings with INI files",
      "tags": ["ini", "config", "settings", "persistence"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-06",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass ConfigManager {\n    __New(iniPath := '') {\n        this.iniPath := iniPath ? iniPath : A_ScriptDir '\\config.ini'\n        this.defaults := Map(\n            'General', Map('Theme', 'dark', 'Language', 'en'),\n            'Window', Map('Width', 800, 'Height', 600, 'X', 100, 'Y', 100)\n        )\n    }\n    \n    Get(section, key) {\n        value := IniRead(this.iniPath, section, key, '')\n        \n        if value = '' && this.defaults.Has(section)\n            if this.defaults[section].Has(key)\n                return this.defaults[section][key]\n        \n        return value\n    }\n    \n    Set(section, key, value) {\n        IniWrite(value, this.iniPath, section, key)\n        return this\n    }\n    \n    GetSection(section) {\n        result := Map()\n        content := IniRead(this.iniPath, section, '')\n        \n        for line in StrSplit(content, '`n') {\n            if InStr(line, '=') {\n                parts := StrSplit(line, '=', , 2)\n                result[parts[1]] := parts[2]\n            }\n        }\n        \n        return result\n    }\n    \n    InitDefaults() {\n        for section, keys in this.defaults {\n            for key, value in keys {\n                if this.Get(section, key) = ''\n                    this.Set(section, key, value)\n            }\n        }\n    }\n}\n\nconfig := ConfigManager()\nconfig.InitDefaults()\n```"
    },
    {
      "id": "clipboard-manager",
      "title": "Clipboard History Manager",
      "category": "System",
      "description": "Store and recall clipboard history",
      "tags": ["clipboard", "history", "system", "productivity"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-07",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass ClipboardManager {\n    static history := []\n    static maxItems := 25\n    static lastClip := ''\n    \n    static Init() {\n        OnClipboardChange(this.OnChange.Bind(this))\n    }\n    \n    static OnChange(dataType) {\n        if dataType = 1 {\n            content := A_Clipboard\n            \n            if content != this.lastClip && content != '' {\n                this.lastClip := content\n                this.history.InsertAt(1, {\n                    content: content,\n                    timestamp: A_Now,\n                    preview: SubStr(content, 1, 50)\n                })\n                \n                if this.history.Length > this.maxItems\n                    this.history.Pop()\n            }\n        }\n    }\n    \n    static ShowHistory() {\n        gui := Gui('+AlwaysOnTop', 'Clipboard History')\n        gui.SetFont('s10', 'Consolas')\n        \n        lv := gui.AddListView('w400 h300', ['#', 'Preview', 'Time'])\n        \n        for i, item in this.history {\n            lv.Add(, i, item.preview, FormatTime(item.timestamp, 'HH:mm:ss'))\n        }\n        \n        lv.OnEvent('DoubleClick', (lv, row) => this.Paste(row))\n        lv.ModifyCol(1, 30)\n        lv.ModifyCol(2, 280)\n        \n        gui.Show()\n    }\n    \n    static Paste(index) {\n        if index > 0 && index <= this.history.Length {\n            A_Clipboard := this.history[index].content\n            Send('^v')\n        }\n    }\n}\n\nClipboardManager.Init()\n^+v::ClipboardManager.ShowHistory()\n```"
    },
    {
      "id": "window-manager",
      "title": "Window Position Manager",
      "category": "System",
      "description": "Save and restore window positions",
      "tags": ["windows", "position", "management", "desktop"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-09",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass WindowManager {\n    static positions := Map()\n    static configFile := A_ScriptDir '\\window-positions.ini'\n    \n    static SaveCurrent() {\n        hwnd := WinGetID('A')\n        title := WinGetTitle(hwnd)\n        processName := WinGetProcessName(hwnd)\n        \n        WinGetPos(&x, &y, &w, &h, hwnd)\n        \n        key := processName '_' StrReplace(title, '=', '')\n        this.positions[key] := {x: x, y: y, w: w, h: h}\n        \n        IniWrite(x ',' y ',' w ',' h, this.configFile, 'Windows', key)\n        ToolTip('Position saved for ' processName)\n        SetTimer(() => ToolTip(), -2000)\n    }\n    \n    static RestoreCurrent() {\n        hwnd := WinGetID('A')\n        title := WinGetTitle(hwnd)\n        processName := WinGetProcessName(hwnd)\n        \n        key := processName '_' StrReplace(title, '=', '')\n        \n        if saved := IniRead(this.configFile, 'Windows', key, '') {\n            parts := StrSplit(saved, ',')\n            WinMove(parts[1], parts[2], parts[3], parts[4], hwnd)\n            ToolTip('Position restored')\n            SetTimer(() => ToolTip(), -2000)\n        }\n    }\n    \n    static CenterWindow() {\n        hwnd := WinGetID('A')\n        WinGetPos(, , &w, &h, hwnd)\n        \n        monInfo := this.GetMonitorInfo(hwnd)\n        x := monInfo.x + (monInfo.w - w) // 2\n        y := monInfo.y + (monInfo.h - h) // 2\n        \n        WinMove(x, y, , , hwnd)\n    }\n    \n    static GetMonitorInfo(hwnd) {\n        ; Get monitor containing window\n        hMon := DllCall('MonitorFromWindow', 'Ptr', hwnd, 'UInt', 2, 'Ptr')\n        \n        monInfo := Buffer(40)\n        NumPut('UInt', 40, monInfo)\n        DllCall('GetMonitorInfo', 'Ptr', hMon, 'Ptr', monInfo)\n        \n        return {\n            x: NumGet(monInfo, 4, 'Int'),\n            y: NumGet(monInfo, 8, 'Int'),\n            w: NumGet(monInfo, 12, 'Int') - NumGet(monInfo, 4, 'Int'),\n            h: NumGet(monInfo, 16, 'Int') - NumGet(monInfo, 8, 'Int')\n        }\n    }\n}\n\n^+s::WindowManager.SaveCurrent()\n^+r::WindowManager.RestoreCurrent()\n^+c::WindowManager.CenterWindow()\n```"
    },
    {
      "id": "process-monitor",
      "title": "Process Monitor",
      "category": "System",
      "description": "Monitor and manage running processes",
      "tags": ["process", "monitor", "system", "management"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-11",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass ProcessMonitor {\n    __New() {\n        this.watched := Map()\n        this.gui := Gui('+Resize', 'Process Monitor')\n        this.gui.SetFont('s9', 'Consolas')\n        \n        this.lv := this.gui.AddListView('w500 h400 Grid', ['PID', 'Name', 'CPU', 'Memory'])\n        \n        btnRefresh := this.gui.AddButton('w80', 'Refresh')\n        btnRefresh.OnEvent('Click', (*) => this.Refresh())\n        \n        btnKill := this.gui.AddButton('x+10 w80', 'End Process')\n        btnKill.OnEvent('Click', (*) => this.KillSelected())\n        \n        this.Refresh()\n        this.gui.Show()\n        \n        SetTimer(this.Refresh.Bind(this), 5000)\n    }\n    \n    Refresh(*) {\n        this.lv.Delete()\n        \n        for proc in ComObjGet('winmgmts:').ExecQuery('SELECT * FROM Win32_Process') {\n            try {\n                memory := Round(proc.WorkingSetSize / 1024 / 1024, 1) ' MB'\n                this.lv.Add(, proc.ProcessId, proc.Name, '--', memory)\n            }\n        }\n        \n        this.lv.ModifyCol(1, 60)\n        this.lv.ModifyCol(2, 200)\n        this.lv.ModifyCol(3, 60)\n        this.lv.ModifyCol(4, 100)\n    }\n    \n    KillSelected() {\n        row := this.lv.GetNext()\n        if row {\n            pid := this.lv.GetText(row, 1)\n            name := this.lv.GetText(row, 2)\n            \n            if MsgBox('Kill process ' name ' (PID: ' pid ')?', 'Confirm', 'YesNo') = 'Yes' {\n                ProcessClose(Integer(pid))\n                this.Refresh()\n            }\n        }\n    }\n}\n\nmonitor := ProcessMonitor()\n```"
    },
    {
      "id": "text-expander",
      "title": "Text Expander",
      "category": "Text Processing",
      "description": "Auto-expand abbreviations into full text",
      "tags": ["text", "expansion", "abbreviations", "typing"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-12",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass TextExpander {\n    static expansions := Map(\n        'btw', 'by the way',\n        'afaik', 'as far as I know',\n        'fyi', 'for your information',\n        'ty', 'thank you',\n        'pls', 'please',\n        'addr', '123 Main Street, City, State 12345',\n        'sig', 'Best regards,`nYour Name`nyour.email@domain.com',\n        'dt', () => FormatTime(A_Now, 'yyyy-MM-dd'),\n        'tm', () => FormatTime(A_Now, 'HH:mm:ss'),\n        'dts', () => FormatTime(A_Now, 'yyyy-MM-dd HH:mm:ss')\n    )\n    \n    static Init() {\n        for abbr, expansion in this.expansions {\n            HotString('::' abbr, this.Expand.Bind(this, expansion))\n        }\n    }\n    \n    static Expand(expansion, *) {\n        text := (expansion is Func) ? expansion.Call() : expansion\n        SendText(text)\n    }\n    \n    static Add(abbr, expansion) {\n        this.expansions[abbr] := expansion\n        HotString('::' abbr, this.Expand.Bind(this, expansion))\n    }\n    \n    static Remove(abbr) {\n        if this.expansions.Has(abbr) {\n            HotString('::' abbr, 'Off')\n            this.expansions.Delete(abbr)\n        }\n    }\n}\n\nTextExpander.Init()\n\n; Add custom expansion\nTextExpander.Add('myemail', 'user@example.com')\n```"
    },
    {
      "id": "string-utils",
      "title": "String Utilities Class",
      "category": "Text Processing",
      "description": "Common string manipulation functions",
      "tags": ["string", "utilities", "text", "manipulation"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-13",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass StringUtils {\n    static ToCamelCase(str) {\n        result := ''\n        capitalize := false\n        \n        for char in StrSplit(str) {\n            if char = ' ' || char = '_' || char = '-' {\n                capitalize := true\n                continue\n            }\n            result .= capitalize ? StrUpper(char) : StrLower(char)\n            capitalize := false\n        }\n        \n        return result\n    }\n    \n    static ToSnakeCase(str) {\n        result := ''\n        \n        for i, char in StrSplit(str) {\n            if RegExMatch(char, '[A-Z]') && i > 1\n                result .= '_'\n            result .= StrLower(char)\n        }\n        \n        return StrReplace(result, ' ', '_')\n    }\n    \n    static ToKebabCase(str) {\n        return StrReplace(this.ToSnakeCase(str), '_', '-')\n    }\n    \n    static Truncate(str, maxLen, suffix := '...') {\n        if StrLen(str) <= maxLen\n            return str\n        return SubStr(str, 1, maxLen - StrLen(suffix)) suffix\n    }\n    \n    static Pad(str, len, char := ' ', side := 'right') {\n        padding := ''\n        loop len - StrLen(str)\n            padding .= char\n        \n        return side = 'left' ? padding str : str padding\n    }\n    \n    static Reverse(str) {\n        result := ''\n        loop parse str\n            result := A_LoopField result\n        return result\n    }\n    \n    static WordCount(str) {\n        return StrSplit(Trim(RegExReplace(str, '\\s+', ' ')), ' ').Length\n    }\n}\n\n; Usage\nMsgBox(StringUtils.ToCamelCase('hello world'))      ; helloWorld\nMsgBox(StringUtils.ToSnakeCase('HelloWorld'))       ; hello_world\nMsgBox(StringUtils.Truncate('Long text here', 10)) ; Long te...\n```"
    },
    {
      "id": "regex-helper",
      "title": "Regular Expression Helper",
      "category": "Text Processing",
      "description": "Utility class for common regex operations",
      "tags": ["regex", "text", "parsing", "validation"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-14",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass RegexHelper {\n    static patterns := Map(\n        'email', '^[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}$',\n        'url', '^https?://[\\w.-]+(?:\\.[a-zA-Z]{2,})+',\n        'phone', '^\\+?[\\d\\s()-]{10,}$',\n        'ipv4', '^(?:\\d{1,3}\\.){3}\\d{1,3}$',\n        'date', '^\\d{4}-\\d{2}-\\d{2}$',\n        'time', '^\\d{2}:\\d{2}(?::\\d{2})?$',\n        'hex', '^#?[0-9a-fA-F]{6}$'\n    )\n    \n    static Validate(str, patternName) {\n        if !this.patterns.Has(patternName)\n            throw ValueError('Unknown pattern: ' patternName)\n        \n        return RegExMatch(str, this.patterns[patternName])\n    }\n    \n    static ExtractAll(str, pattern) {\n        results := []\n        pos := 1\n        \n        while pos := RegExMatch(str, pattern, &match, pos) {\n            results.Push(match[])\n            pos += StrLen(match[])\n        }\n        \n        return results\n    }\n    \n    static ReplaceAll(str, pattern, replacement) {\n        return RegExReplace(str, pattern, replacement)\n    }\n    \n    static ExtractEmails(str) {\n        return this.ExtractAll(str, '[\\w.-]+@[\\w.-]+\\.[a-zA-Z]{2,}')\n    }\n    \n    static ExtractUrls(str) {\n        return this.ExtractAll(str, 'https?://[^\\s<>\"]+'))\n    }\n    \n    static ExtractNumbers(str) {\n        return this.ExtractAll(str, '-?\\d+\\.?\\d*')\n    }\n}\n\n; Usage\ntext := 'Contact: user@example.com or visit https://example.com'\nemails := RegexHelper.ExtractEmails(text)\nurls := RegexHelper.ExtractUrls(text)\n\nMsgBox('Valid email: ' (RegexHelper.Validate('test@test.com', 'email') ? 'Yes' : 'No'))\n```"
    },
    {
      "id": "auto-clicker",
      "title": "Auto Clicker with GUI",
      "category": "Automation",
      "description": "Configurable auto-clicker with interval settings",
      "tags": ["automation", "clicker", "mouse", "gui"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-15",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass AutoClicker {\n    __New() {\n        this.running := false\n        this.interval := 100\n        this.clickType := 'Left'\n        \n        this.gui := Gui('+AlwaysOnTop', 'Auto Clicker')\n        this.gui.SetFont('s10', 'Segoe UI')\n        \n        this.gui.AddText(, 'Interval (ms):')\n        this.intervalEdit := this.gui.AddEdit('w100 Number', this.interval)\n        \n        this.gui.AddText('xm', 'Click Type:')\n        this.clickDD := this.gui.AddDropDownList('w100 Choose1', ['Left', 'Right', 'Middle'])\n        \n        this.statusText := this.gui.AddText('xm w150', 'Status: Stopped')\n        \n        this.toggleBtn := this.gui.AddButton('xm w100', 'Start (F6)')\n        this.toggleBtn.OnEvent('Click', (*) => this.Toggle())\n        \n        this.gui.OnEvent('Close', (*) => ExitApp())\n        this.gui.Show()\n        \n        Hotkey('F6', (*) => this.Toggle())\n    }\n    \n    Toggle() {\n        this.running := !this.running\n        \n        if this.running {\n            this.interval := Integer(this.intervalEdit.Value)\n            this.clickType := this.clickDD.Text\n            this.statusText.Value := 'Status: Running'\n            this.toggleBtn.Text := 'Stop (F6)'\n            SetTimer(this.DoClick.Bind(this), this.interval)\n        } else {\n            this.statusText.Value := 'Status: Stopped'\n            this.toggleBtn.Text := 'Start (F6)'\n            SetTimer(this.DoClick.Bind(this), 0)\n        }\n    }\n    \n    DoClick() {\n        Click(this.clickType)\n    }\n}\n\napp := AutoClicker()\n```"
    },
    {
      "id": "macro-recorder",
      "title": "Simple Macro Recorder",
      "category": "Automation",
      "description": "Record and playback keyboard/mouse actions",
      "tags": ["automation", "macro", "recording", "playback"],
      "difficulty": "advanced",
      "dateAdded": "2025-12-16",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass MacroRecorder {\n    __New() {\n        this.recording := false\n        this.playing := false\n        this.actions := []\n        this.lastTime := 0\n        \n        this.gui := Gui('+AlwaysOnTop', 'Macro Recorder')\n        this.gui.SetFont('s10', 'Segoe UI')\n        \n        this.statusText := this.gui.AddText('w200', 'Press F9 to Record')\n        this.countText := this.gui.AddText('w200', 'Actions: 0')\n        \n        this.gui.AddText('xm', 'F9: Record | F10: Play | F11: Clear')\n        this.gui.Show()\n        \n        Hotkey('F9', (*) => this.ToggleRecord())\n        Hotkey('F10', (*) => this.Play())\n        Hotkey('F11', (*) => this.Clear())\n    }\n    \n    ToggleRecord() {\n        this.recording := !this.recording\n        \n        if this.recording {\n            this.actions := []\n            this.lastTime := A_TickCount\n            this.statusText.Value := 'Recording...'\n            this.InstallHooks()\n        } else {\n            this.statusText.Value := 'Stopped (' this.actions.Length ' actions)'\n            this.RemoveHooks()\n        }\n    }\n    \n    InstallHooks() {\n        this.keyHook := InputHook('V')\n        this.keyHook.KeyOpt('{All}', 'N')\n        this.keyHook.OnKeyDown := this.OnKey.Bind(this)\n        this.keyHook.Start()\n    }\n    \n    RemoveHooks() {\n        if this.keyHook\n            this.keyHook.Stop()\n    }\n    \n    OnKey(ih, vk, sc) {\n        delay := A_TickCount - this.lastTime\n        this.lastTime := A_TickCount\n        \n        this.actions.Push({type: 'key', vk: vk, sc: sc, delay: delay})\n        this.countText.Value := 'Actions: ' this.actions.Length\n    }\n    \n    Play() {\n        if this.recording || this.playing || !this.actions.Length\n            return\n        \n        this.playing := true\n        this.statusText.Value := 'Playing...'\n        \n        for action in this.actions {\n            Sleep(action.delay)\n            if action.type = 'key'\n                Send('{vk' Format('{:02X}', action.vk) '}')\n        }\n        \n        this.playing := false\n        this.statusText.Value := 'Done'\n    }\n    \n    Clear() {\n        this.actions := []\n        this.countText.Value := 'Actions: 0'\n        this.statusText.Value := 'Cleared'\n    }\n}\n\napp := MacroRecorder()\n```"
    },
    {
      "id": "base-class-pattern",
      "title": "Base Class Pattern",
      "category": "Classes",
      "description": "Reusable base class with common functionality",
      "tags": ["class", "oop", "pattern", "inheritance"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-17",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass BaseComponent {\n    static instances := Map()\n    \n    __New(name := '') {\n        this.id := this.GenerateId()\n        this.name := name ? name : 'Component_' this.id\n        this.created := A_Now\n        this.events := Map()\n        \n        BaseComponent.instances[this.id] := this\n    }\n    \n    __Delete() {\n        if BaseComponent.instances.Has(this.id)\n            BaseComponent.instances.Delete(this.id)\n    }\n    \n    GenerateId() {\n        static counter := 0\n        return ++counter\n    }\n    \n    On(eventName, callback) {\n        if !this.events.Has(eventName)\n            this.events[eventName] := []\n        this.events[eventName].Push(callback)\n        return this\n    }\n    \n    Off(eventName, callback := '') {\n        if !this.events.Has(eventName)\n            return this\n        \n        if callback = ''\n            this.events.Delete(eventName)\n        else {\n            handlers := this.events[eventName]\n            for i, handler in handlers {\n                if handler = callback {\n                    handlers.RemoveAt(i)\n                    break\n                }\n            }\n        }\n        return this\n    }\n    \n    Emit(eventName, args*) {\n        if this.events.Has(eventName) {\n            for handler in this.events[eventName]\n                handler.Call(args*)\n        }\n        return this\n    }\n    \n    ToString() {\n        return this.name ' (ID: ' this.id ')'\n    }\n}\n\n; Usage - Extend the base class\nclass Button extends BaseComponent {\n    __New(label) {\n        super.__New('Button')\n        this.label := label\n    }\n    \n    Click() {\n        this.Emit('click', this)\n    }\n}\n\nbtn := Button('Submit')\nbtn.On('click', (b) => MsgBox('Clicked: ' b.label))\nbtn.Click()\n```"
    },
    {
      "id": "singleton-pattern",
      "title": "Singleton Pattern",
      "category": "Classes",
      "description": "Ensure only one instance of a class exists",
      "tags": ["class", "singleton", "pattern", "design"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-18",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass AppSettings {\n    static _instance := ''\n    \n    settings := Map(\n        'theme', 'dark',\n        'language', 'en',\n        'autoSave', true,\n        'fontSize', 12\n    )\n    \n    __New() {\n        if AppSettings._instance\n            throw Error('Use AppSettings.Instance instead')\n    }\n    \n    static Instance {\n        get {\n            if !this._instance\n                this._instance := AppSettings()\n            return this._instance\n        }\n    }\n    \n    Get(key, defaultVal := '') {\n        return this.settings.Has(key) ? this.settings[key] : defaultVal\n    }\n    \n    Set(key, value) {\n        this.settings[key] := value\n        return this\n    }\n    \n    GetAll() {\n        return this.settings.Clone()\n    }\n}\n\n; Usage - Always gets the same instance\nsettings1 := AppSettings.Instance\nsettings2 := AppSettings.Instance\n\nsettings1.Set('theme', 'light')\nMsgBox(settings2.Get('theme'))  ; 'light' - same instance\n```"
    },
    {
      "id": "observer-pattern",
      "title": "Observer Pattern",
      "category": "Classes",
      "description": "Implement publish-subscribe event system",
      "tags": ["class", "observer", "pattern", "events"],
      "difficulty": "advanced",
      "dateAdded": "2025-12-19",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass EventEmitter {\n    __New() {\n        this.listeners := Map()\n    }\n    \n    Subscribe(event, callback) {\n        if !this.listeners.Has(event)\n            this.listeners[event] := []\n        \n        id := A_TickCount '_' Random(1000, 9999)\n        this.listeners[event].Push({id: id, callback: callback})\n        \n        return id\n    }\n    \n    Unsubscribe(event, id) {\n        if !this.listeners.Has(event)\n            return false\n        \n        for i, listener in this.listeners[event] {\n            if listener.id = id {\n                this.listeners[event].RemoveAt(i)\n                return true\n            }\n        }\n        return false\n    }\n    \n    Publish(event, data := '') {\n        if !this.listeners.Has(event)\n            return 0\n        \n        count := 0\n        for listener in this.listeners[event] {\n            listener.callback.Call(data)\n            count++\n        }\n        return count\n    }\n    \n    Once(event, callback) {\n        wrapper := ''\n        wrapper := (data) => (\n            callback.Call(data),\n            this.Unsubscribe(event, id)\n        )\n        id := this.Subscribe(event, wrapper)\n        return id\n    }\n}\n\n; Usage\nclass DataStore extends EventEmitter {\n    __New() {\n        super.__New()\n        this.data := Map()\n    }\n    \n    Set(key, value) {\n        oldValue := this.data.Has(key) ? this.data[key] : ''\n        this.data[key] := value\n        \n        this.Publish('change', {key: key, old: oldValue, new: value})\n        this.Publish('change:' key, value)\n    }\n}\n\nstore := DataStore()\nstore.Subscribe('change', (e) => ToolTip(e.key ': ' e.new))\nstore.Set('username', 'John')\n```"
    },
    {
      "id": "http-client",
      "title": "HTTP Client Class",
      "category": "Networking",
      "description": "Simple HTTP client using WinHTTP",
      "tags": ["http", "networking", "api", "web"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-01",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass HttpClient {\n    __New(baseUrl := '') {\n        this.baseUrl := baseUrl\n        this.headers := Map(\n            'User-Agent', 'AHKv2-HttpClient/1.0',\n            'Content-Type', 'application/json'\n        )\n    }\n    \n    Request(method, url, body := '') {\n        fullUrl := this.baseUrl ? this.baseUrl url : url\n        \n        whr := ComObject('WinHttp.WinHttpRequest.5.1')\n        whr.Open(method, fullUrl, false)\n        \n        for name, value in this.headers\n            whr.SetRequestHeader(name, value)\n        \n        try {\n            whr.Send(body)\n            return {\n                status: whr.Status,\n                statusText: whr.StatusText,\n                body: whr.ResponseText,\n                headers: whr.GetAllResponseHeaders()\n            }\n        } catch as err {\n            return {status: 0, error: err.Message}\n        }\n    }\n    \n    Get(url) {\n        return this.Request('GET', url)\n    }\n    \n    Post(url, data) {\n        body := (data is Map || data is Object) ? JSON.Dump(data) : data\n        return this.Request('POST', url, body)\n    }\n    \n    Put(url, data) {\n        body := (data is Map || data is Object) ? JSON.Dump(data) : data\n        return this.Request('PUT', url, body)\n    }\n    \n    Delete(url) {\n        return this.Request('DELETE', url)\n    }\n    \n    SetHeader(name, value) {\n        this.headers[name] := value\n        return this\n    }\n}\n\n; Usage\napi := HttpClient('https://api.example.com')\nresponse := api.Get('/users')\n\nif response.status = 200\n    MsgBox(response.body)\n```"
    },
    {
      "id": "websocket-client",
      "title": "WebSocket Client",
      "category": "Networking",
      "description": "Basic WebSocket connection using IE COM",
      "tags": ["websocket", "networking", "realtime", "web"],
      "difficulty": "advanced",
      "dateAdded": "2025-12-02",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass WebSocketClient {\n    __New(url) {\n        this.url := url\n        this.connected := false\n        this.onMessage := ''\n        this.onClose := ''\n        this.onError := ''\n        \n        this.ie := ComObject('InternetExplorer.Application')\n        this.ie.Visible := false\n        this.ie.Navigate('about:blank')\n        \n        while this.ie.Busy\n            Sleep(10)\n    }\n    \n    Connect() {\n        script := '\n        (\n            window.ws = new WebSocket(\"' this.url '\");\n            window.messages = [];\n            window.wsStatus = \"connecting\";\n            \n            ws.onopen = function() {\n                window.wsStatus = \"connected\";\n            };\n            \n            ws.onmessage = function(e) {\n                window.messages.push(e.data);\n            };\n            \n            ws.onclose = function() {\n                window.wsStatus = \"closed\";\n            };\n            \n            ws.onerror = function() {\n                window.wsStatus = \"error\";\n            };\n        )'\n        \n        this.ie.Document.parentWindow.execScript(script)\n        \n        ; Wait for connection\n        loop 50 {\n            status := this.ie.Document.parentWindow.wsStatus\n            if status = 'connected' {\n                this.connected := true\n                return true\n            }\n            if status = 'error'\n                return false\n            Sleep(100)\n        }\n        return false\n    }\n    \n    Send(message) {\n        if !this.connected\n            return false\n        this.ie.Document.parentWindow.ws.send(message)\n        return true\n    }\n    \n    Receive() {\n        messages := this.ie.Document.parentWindow.messages\n        result := []\n        \n        while messages.length > 0\n            result.Push(messages.shift())\n        \n        return result\n    }\n    \n    Close() {\n        if this.connected\n            this.ie.Document.parentWindow.ws.close()\n        this.ie.Quit()\n    }\n}\n\n; Usage\nws := WebSocketClient('wss://echo.websocket.org')\nif ws.Connect() {\n    ws.Send('Hello WebSocket!')\n    Sleep(1000)\n    messages := ws.Receive()\n    for msg in messages\n        MsgBox(msg)\n    ws.Close()\n}\n```"
    },
    {
      "id": "dll-wrapper",
      "title": "DLL Function Wrapper",
      "category": "Windows API",
      "description": "Helper class for calling Windows API functions",
      "tags": ["dll", "windows-api", "wrapper", "system"],
      "difficulty": "advanced",
      "dateAdded": "2025-12-03",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass WinAPI {\n    ; Message Box flags\n    static MB_OK := 0x0\n    static MB_YESNO := 0x4\n    static MB_ICONINFO := 0x40\n    static MB_ICONWARNING := 0x30\n    static MB_ICONERROR := 0x10\n    \n    ; Window styles\n    static WS_VISIBLE := 0x10000000\n    static WS_POPUP := 0x80000000\n    \n    static MessageBox(text, title := '', flags := 0) {\n        return DllCall('MessageBoxW',\n            'Ptr', 0,\n            'Str', text,\n            'Str', title,\n            'UInt', flags)\n    }\n    \n    static GetCursorPos() {\n        pt := Buffer(8)\n        DllCall('GetCursorPos', 'Ptr', pt)\n        return {\n            x: NumGet(pt, 0, 'Int'),\n            y: NumGet(pt, 4, 'Int')\n        }\n    }\n    \n    static SetCursorPos(x, y) {\n        return DllCall('SetCursorPos', 'Int', x, 'Int', y)\n    }\n    \n    static GetSystemMetrics(index) {\n        return DllCall('GetSystemMetrics', 'Int', index)\n    }\n    \n    static GetScreenWidth() {\n        return this.GetSystemMetrics(0)  ; SM_CXSCREEN\n    }\n    \n    static GetScreenHeight() {\n        return this.GetSystemMetrics(1)  ; SM_CYSCREEN\n    }\n    \n    static PlaySound(soundFile, flags := 0x20001) {\n        return DllCall('winmm\\PlaySoundW',\n            'Str', soundFile,\n            'Ptr', 0,\n            'UInt', flags)\n    }\n    \n    static SetWindowPos(hwnd, x, y, w, h, flags := 0) {\n        return DllCall('SetWindowPos',\n            'Ptr', hwnd,\n            'Ptr', 0,\n            'Int', x, 'Int', y,\n            'Int', w, 'Int', h,\n            'UInt', flags)\n    }\n    \n    static GetWindowRect(hwnd) {\n        rect := Buffer(16)\n        DllCall('GetWindowRect', 'Ptr', hwnd, 'Ptr', rect)\n        return {\n            left: NumGet(rect, 0, 'Int'),\n            top: NumGet(rect, 4, 'Int'),\n            right: NumGet(rect, 8, 'Int'),\n            bottom: NumGet(rect, 12, 'Int')\n        }\n    }\n}\n\n; Usage\npos := WinAPI.GetCursorPos()\nMsgBox('Cursor at: ' pos.x ', ' pos.y)\n\nscreenW := WinAPI.GetScreenWidth()\nscreenH := WinAPI.GetScreenHeight()\nMsgBox('Screen: ' screenW 'x' screenH)\n```"
    },
    {
      "id": "registry-helper",
      "title": "Registry Helper Class",
      "category": "Windows API",
      "description": "Simplified Windows Registry operations",
      "tags": ["registry", "windows", "system", "settings"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-04",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass Registry {\n    static Read(keyPath, valueName := '', defaultVal := '') {\n        try {\n            return RegRead(keyPath, valueName)\n        } catch {\n            return defaultVal\n        }\n    }\n    \n    static Write(keyPath, valueName, value, valueType := 'REG_SZ') {\n        try {\n            RegWrite(value, valueType, keyPath, valueName)\n            return true\n        } catch {\n            return false\n        }\n    }\n    \n    static Delete(keyPath, valueName := '') {\n        try {\n            if valueName\n                RegDelete(keyPath, valueName)\n            else\n                RegDeleteKey(keyPath)\n            return true\n        } catch {\n            return false\n        }\n    }\n    \n    static KeyExists(keyPath) {\n        try {\n            loop reg keyPath\n                return true\n            return true\n        } catch {\n            return false\n        }\n    }\n    \n    static GetValues(keyPath) {\n        values := Map()\n        try {\n            loop reg keyPath {\n                if A_LoopRegType != 'KEY'\n                    values[A_LoopRegName] := RegRead(keyPath, A_LoopRegName)\n            }\n        }\n        return values\n    }\n    \n    static GetSubKeys(keyPath) {\n        keys := []\n        try {\n            loop reg keyPath, 'K'\n                keys.Push(A_LoopRegName)\n        }\n        return keys\n    }\n    \n    ; Common registry paths\n    static GetStartupFolder() {\n        return this.Read('HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders', 'Startup')\n    }\n    \n    static AddToStartup(name, path) {\n        return this.Write(\n            'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',\n            name, path)\n    }\n    \n    static RemoveFromStartup(name) {\n        return this.Delete(\n            'HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run',\n            name)\n    }\n}\n\n; Usage\nwallpaper := Registry.Read(\n    'HKEY_CURRENT_USER\\Control Panel\\Desktop',\n    'WallPaper')\nMsgBox('Current wallpaper: ' wallpaper)\n```"
    },
    {
      "id": "timer-scheduler",
      "title": "Timer Scheduler",
      "category": "Utilities",
      "description": "Schedule and manage multiple timers",
      "tags": ["timer", "scheduler", "utilities", "async"],
      "difficulty": "intermediate",
      "dateAdded": "2025-12-05",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass TimerScheduler {\n    static timers := Map()\n    static counter := 0\n    \n    static SetTimeout(callback, delay) {\n        id := ++this.counter\n        \n        wrapper := () => (\n            SetTimer(this.timers[id].fn, 0),\n            this.timers.Delete(id),\n            callback.Call()\n        )\n        \n        this.timers[id] := {fn: wrapper, type: 'timeout'}\n        SetTimer(wrapper, -delay)\n        \n        return id\n    }\n    \n    static SetInterval(callback, interval) {\n        id := ++this.counter\n        \n        wrapper := () => callback.Call()\n        \n        this.timers[id] := {fn: wrapper, type: 'interval', interval: interval}\n        SetTimer(wrapper, interval)\n        \n        return id\n    }\n    \n    static Clear(id) {\n        if this.timers.Has(id) {\n            SetTimer(this.timers[id].fn, 0)\n            this.timers.Delete(id)\n            return true\n        }\n        return false\n    }\n    \n    static ClearAll() {\n        for id, timer in this.timers\n            SetTimer(timer.fn, 0)\n        this.timers.Clear()\n    }\n    \n    static Pause(id) {\n        if this.timers.Has(id) {\n            SetTimer(this.timers[id].fn, 0)\n            this.timers[id].paused := true\n            return true\n        }\n        return false\n    }\n    \n    static Resume(id) {\n        if this.timers.Has(id) && this.timers[id].paused {\n            interval := this.timers[id].type = 'interval' ? this.timers[id].interval : -1000\n            SetTimer(this.timers[id].fn, interval)\n            this.timers[id].paused := false\n            return true\n        }\n        return false\n    }\n}\n\n; Usage\nTimerScheduler.SetTimeout(() => MsgBox('5 seconds passed!'), 5000)\n\nid := TimerScheduler.SetInterval(() => ToolTip(A_TickCount), 1000)\n\n; Stop after 10 seconds\nTimerScheduler.SetTimeout(() => TimerScheduler.Clear(id), 10000)\n```"
    },
    {
      "id": "logger-class",
      "title": "Logger Class",
      "category": "Utilities",
      "description": "Logging utility with file output and levels",
      "tags": ["logging", "debug", "utilities", "files"],
      "difficulty": "beginner",
      "dateAdded": "2025-12-06",
      "lastModified": "2025-12-20",
      "code": "```cpp\n#Requires AutoHotkey v2.0\n\nclass Logger {\n    static levels := Map(\n        'DEBUG', 10,\n        'INFO', 20,\n        'WARN', 30,\n        'ERROR', 40\n    )\n    \n    __New(logFile := '', minLevel := 'DEBUG') {\n        this.logFile := logFile ? logFile : A_ScriptDir '\\app.log'\n        this.minLevel := minLevel\n        this.console := true\n        this.timestamps := true\n    }\n    \n    Log(level, message, data := '') {\n        if Logger.levels[level] < Logger.levels[this.minLevel]\n            return\n        \n        timestamp := this.timestamps ? '[' FormatTime(A_Now, 'yyyy-MM-dd HH:mm:ss') '] ' : ''\n        entry := timestamp '[' level '] ' message\n        \n        if data != ''\n            entry .= ' | Data: ' String(data)\n        \n        if this.console\n            OutputDebug(entry)\n        \n        if this.logFile {\n            try FileAppend(entry '`n', this.logFile, 'UTF-8')\n        }\n    }\n    \n    Debug(message, data := '') {\n        this.Log('DEBUG', message, data)\n    }\n    \n    Info(message, data := '') {\n        this.Log('INFO', message, data)\n    }\n    \n    Warn(message, data := '') {\n        this.Log('WARN', message, data)\n    }\n    \n    Error(message, data := '') {\n        this.Log('ERROR', message, data)\n    }\n    \n    Clear() {\n        if FileExist(this.logFile)\n            FileDelete(this.logFile)\n    }\n}\n\n; Usage\nlog := Logger()\nlog.minLevel := 'INFO'\n\nlog.Debug('This wont show')  ; Below minimum level\nlog.Info('Application started')\nlog.Warn('Low memory', {available: '256MB'})\nlog.Error('Failed to connect', {host: 'localhost', port: 8080})\n```"
    }
  ]
}
